# AtCoder Grand Contest 007

## [AC-][AGC007] D - Shik and Game

### 方針

まず O( N^2 ) の dp を立てて、次にその dp の計算量を減らすことを考える。

$dp[i]$ を、(i番目のコインを集めるのに必要な最短時間) - (入り口からクマ i までの距離) とする。このとき、

$$
dp[i] = \min_{j < i} (dp[j] + \max(T, 2 (x[i] - x[j + 1])))
$$

が成り立つ。これを普通に求めたら O( N^2 ) になってとりあえず部分点がもらえる。

次に、計算量を減らすことを考える。

そのためにまず、 $\max(T, 2 (x[i] - x[j + 1]))$ の部分に注目して、場合分けをする。

1. $2 (x[i] - x[j + 1]) > T ~ (j < p)$
2. $2 (x[i] - x[j + 1]) \le T ~ (p \le j)$

となるような j のしきい値を p とする。p は i が増えるごとに単調増加するので、p を求める処理は全体で高々 N 回で済む。

1. $2 (x[i] - x[j + 1]) > T$ のとき  
    上の式は $dp[i] = \min_{j < p} (dp[j] - 2 x[j + 1]) + 2 x[i]$ と書き直せる。min の部分は、新しく dp[i] が求まるごとに最小値を更新しておけばいいので、O( 1 ) で求められる。
2. $2 (x[i] - x[j + 1]) \le T$ のとき  
    上の式は $dp[i] = \min_{p \le j < i} (dp[j]) + T$ と書き直せる。min の部分は、セグメント木を使った RMQ で O( log N ) で実現できる。

以上のようにして、 dp を O( N log N ) で行うことができるようになった。


### 計算量

O( N log N )


### keywords

RMQ, SegmentTree, dp

