# [ARC087] E - Prefix-free Game

## 問題概要

`0`, `1` からなる相互に prefix-free な文字列の集合 S = { s_1, s_2, …, s_N } が与えられる。
この集合に Alice と Bob が交互に新しい文字列を追加していく。ただし、追加後の S に含まれる文字列同士が prefix-free な状態を保つようにする。
先に操作を行えなくなった方を負けとするとき、勝つのはどちらか。


## 方針

trie + grundy 数。（trie + nim か? と疑うところまではできたが、そこから grundy 数を使う方法を考えつくことまではできなかった。。）

まず、 s_1, …, s_N を trie を使って保持しておく。 このとき、 S を prefix-free な文字列集合に保つことと各 s_i に対応するノードが葉であることは同値である。

この trie 上に条件を保ったまま新しく追加できる文字列に対応するノードの集合は、いくつかの完全二分木の和になっている。これらの完全二分木どうしは先祖-子孫の関係ではないので、移行独立に考える。

あらたな長さlの文字列を追加したときについて考える。この文字列の対応するノードを n とする。 n を含む完全二分木の高さを h とすると、高さ h の完全二分木が一つ減り、代わりに高さ h - 1, h - 2, …, L - l の完全二分木が増える。このようなゲームの勝敗判定には Grundy 数を用いるのが有効である。

一般に、ある状態 s の Grundy 数 g(s) は、s から1手で行ける状態を a, b, … とすると、

```
g(s) = { g(a), g(b), ... } に含まれない最小の非負整数
```

と定めると良い。今回のケースでは、完全二分木の高さを h とすると、

```
g(h) = {0, g(h-1), g(h-1) XOR g(h-2), …, g(h-1) XOR … XOR g(1)} に含まれない最小の非負整数
```

となる。ちなみに、今回の Grundy 数は `g(h) = (i を割り切る最大の 2 の冪) ` となっている。

まとめると、

1. 入力に対して trie を構築
2. 子がちょうど1つであるようなノード（深さd）に対して、 Grundy 数 g(L - d) を計算
3. すべての Grundy 数を XOR を計算
4. 総 XOR が 0 => Alice, 1 => Bob の勝ち

とすればよい。


## 計算量

O( N )


## keywords

Grundy 数, trie, 木
